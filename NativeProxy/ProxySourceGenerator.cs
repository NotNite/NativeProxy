using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace NativeProxy;

[Generator]
public class ProxySourceGenerator : IIncrementalGenerator {
    private const string FileStart = "NativeProxy.";
    private const string FileEnd = ".txt";

    private const string AttributeCode = @"// <auto-generated/>

using System;

namespace NativeProxy {
    [AttributeUsage(AttributeTargets.Method)]
    public sealed class ProxyEntrypointAttribute : Attribute {}
}
";

    private const string LoaderCode = @"// <auto-generated/>

using System;
using System.Runtime.InteropServices;
using System.Text;

namespace NativeProxy {
    public static class Loader {
        public const uint DllProcessDetach = 0;
        public const uint DllProcessAttach = 1;
        public const uint DllThreadAttach = 2;
        public const uint DllThreadDetach = 3;
        public const uint PageExecuteReadWrite = 0x40;

        public const uint LoadLibrarySearchSystem32 = 0x800;
        public const uint LoadLibrarySearchUserDirs = 0x400;

        [UnmanagedCallersOnly(EntryPoint = ""DllMain"")]
        public static bool DllMain(nint module, uint reasonForCall, nint reserved) {
            switch (reasonForCall) {
                case DllProcessAttach: {
                    Run(module);
                    /*ENTRYPOINT*/
                    break;
                }
            }

            return true;
        }

        public static string GetModuleName(nint module) {
            var filenameBuf = new byte[1024];
            _ = GetModuleFileName(module, filenameBuf, filenameBuf.Length);
            return Encoding.Unicode.GetString(filenameBuf).TrimEnd('\0');
        }

        public static nint GetModuleHandle(string path) {
            // todo this logic sucks
            var filename = Path.GetFileName(path);
            string origPath = /*ORIGPATH*/;
            if (origPath == null) origPath = path.Replace("".dll"", "".orig.dll"");
            if (!Path.IsPathRooted(origPath)) {
                var dir = Path.GetDirectoryName(path)!;
                origPath = Path.Combine(dir, origPath);
            }
            return LoadLibrary(origPath);
        }

        public static unsafe void Run(nint ourHandle) {
            Dictionary<string, string[]> exportsTable = new() {
                /*EXPORTS*/
            };
            var filename = GetModuleName(ourHandle);
            if (!exportsTable.TryGetValue(Path.GetFileNameWithoutExtension(filename), out var exports)) return;
            var theirHandle = GetModuleHandle(filename);

            foreach (var export in exports) {
                var theirExport = GetProcAddress(theirHandle, export);
                var ourExport = GetProcAddress(ourHandle, export);
                if (theirExport == nint.Zero || ourExport == nint.Zero) continue;

                var jump = AssembleJump(theirExport);
                if (VirtualProtect(ourExport, jump.Length, PageExecuteReadWrite, out var oldProtect) != 1) continue;
                var span = new Span<byte>((byte*) ourExport, jump.Length);
                jump.CopyTo(span);
                VirtualProtect(ourExport, jump.Length, oldProtect, out _);
            }
        }

        public static unsafe byte[] AssembleJump(nint addr) {
            byte[] shellcode;
            int offset;
            if (sizeof(nint) == 4) {
                shellcode = [
                    // mov eax,
                    0xB8,
                    // addr
                    0x00, 0x00, 0x00, 0x00,
                    // jmp eax
                    0xFF, 0xE0
                ];
                offset = 1;
            } else {
                shellcode = [
                    // mov r11,
                    0x49, 0xBB,
                    // addr
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    // jmp r11
                    0x41, 0xFF, 0xE3
                ];
                offset = 2;
            }

            var addrBytes = BitConverter.GetBytes(addr);
            Array.Copy(addrBytes, 0, shellcode, offset, sizeof(nint));

            return shellcode;
        }

        [DllImport(""kernel32.dll"", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint LoadLibraryEx(string filename, nint reserved, uint flags);

        [DllImport(""kernel32.dll"", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint LoadLibrary(string filename);

        [DllImport(""kernel32.dll"", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetModuleFileName(nint module, byte[] filename, int size);

        [DllImport(""kernel32.dll"", SetLastError = true, CharSet = CharSet.Ansi)]
        public static extern nint GetProcAddress(nint module, string procName);

        [DllImport(""kernel32.dll"", SetLastError = true)]
        public static extern byte VirtualProtect(nint address, nint size, uint newProtect, out uint oldProtect);
    }
}
";

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        context.RegisterPostInitializationOutput(static postInitializationContext =>
            postInitializationContext.AddSource("NativeProxy.g.cs", SourceText.From(AttributeCode, Encoding.UTF8)));

        var exportsPipeline = context.AdditionalTextsProvider
            .Where(static text => {
                var name = Path.GetFileName(text.Path);
                return name.StartsWith(FileStart) && name.EndsWith(FileEnd);
            })
            .Select(GetExports)
            .Where(static content => content is not null);

        context.RegisterSourceOutput(exportsPipeline, static (context, pair) => {
            var stubs = pair!.Value.Item2
                .Distinct()
                .Select(x => $$"""
                                       [System.Runtime.InteropServices.UnmanagedCallersOnly(EntryPoint = "{{x}}")]
                                       public static void {{x}}() {
                                           // Stub
                                           for (var i = 0; i < 1000; i++) System.Threading.Thread.Sleep(1000);
                                       }
                               """.Trim());
            var code = string.Join("\n", stubs);
            var source = @$"// <auto-generated/>
namespace NativeProxy {{
    public static class Exports {{
        {code}
    }}
}}
";

            context.AddSource(pair.Value.Item1 + ".g.cs", SourceText.From(source, Encoding.UTF8));
        });

        var entrypointPipeline = context.SyntaxProvider.ForAttributeWithMetadataName(
            fullyQualifiedMetadataName: "NativeProxy.ProxyEntrypointAttribute",
            predicate: static (syntaxNode, cancellationToken) => syntaxNode is BaseMethodDeclarationSyntax,
            transform: static (context, cancellationToken) => {
                var methodName = context.TargetSymbol.Name;
                var containingType = context.TargetSymbol.ContainingType;
                var containingNamespace = containingType
                    .ContainingNamespace?
                    .ToDisplayString(
                        SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(
                            SymbolDisplayGlobalNamespaceStyle.Omitted));
                return containingNamespace is null
                           ? null
                           : $"{containingNamespace}.{containingType.Name}.{methodName}();";
            }
        ).Collect();

        var origPathPipeline = context.AnalyzerConfigOptionsProvider.Select((provider, ct) =>
            provider.GlobalOptions.TryGetValue("build_property.NativeProxy_OriginalPath", out var origPath)
                ? origPath
                : "null");
        context.RegisterSourceOutput(exportsPipeline.Collect().Combine(entrypointPipeline).Combine(origPathPipeline),
            static (context, pair) => {
                var exports = pair!.Left.Left;
                var entrypoint = pair.Left.Right.FirstOrDefault();
                var origPath = pair.Right;

                var exportsStr = new StringBuilder();
                foreach (var pair2 in exports) {
                    if (pair2 == null) continue;
                    exportsStr.Append("{\"");
                    exportsStr.Append(pair2.Value.Item1);
                    exportsStr.Append("\", new string[] {");
                    exportsStr.Append(string.Join(", ", pair2.Value.Item2.Select(x => $"\"{x}\"")));
                    exportsStr.Append("}},\n");
                }

                var code = LoaderCode
                    .Replace("/*ORIGPATH*/", "\"" + origPath + "\"")
                    .Replace("/*ENTRYPOINT*/", entrypoint ?? "")
                    .Replace("/*EXPORTS*/", exportsStr.ToString());

                context.AddSource("NativeProxy.Loader.g.cs", SourceText.From(code, Encoding.UTF8));
            });
    }

    private static (string, List<string>)? GetExports(AdditionalText text, CancellationToken ct) {
        var fileName = Path.GetFileName(text.Path);
        var dllName = fileName
            .Substring(FileStart.Length)
            .Substring(0, fileName.Length - FileStart.Length - FileEnd.Length);

        var content = text.GetText(ct);
        if (content is null) return null;

        var lines = content.Lines
            .Where(x => x.Text is not null)
            .Select(x => x.Text!.ToString().Trim())
            .Distinct();
        return (dllName, lines.ToList());
    }
}
